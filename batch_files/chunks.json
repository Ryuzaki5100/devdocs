{ 
  "demo/src/main/java/com/devdocs/demo/DemoApplication.java ": 
{"imports":["org.springframework.boot.SpringApplication","org.springframework.boot.autoconfigure.SpringBootApplication"],"classes":[{"name":"DemoApplication","annotations":["SpringBootApplication"],"extendedClass":"","implementedInterfaces":[],"fields":[],"methods":[{"name":"main","returnType":"void","annotations":[],"parameters":["String[] args"],"body":"{\n    SpringApplication.run(DemoApplication.class, args);\n}"}],"nestedClasses":[]}]}  , "demo/src/main/java/com/devdocs/demo/controllers/CreateDocumentationController.java ": 
{"imports":["org.springframework.core.io.InputStreamResource","org.springframework.http.HttpHeaders","org.springframework.http.MediaType","org.springframework.http.ResponseEntity","org.springframework.web.bind.annotation","java.io","java.util.ArrayList","java.util.List","com.itextpdf.text","com.itextpdf.text.pdf.PdfWriter"],"classes":[{"name":"DevController","annotations":["RestController","RequestMapping"],"extendedClass":"","implementedInterfaces":[],"fields":[],"methods":[{"name":"getdocs","returnType":"ResponseEntity<InputStreamResource>","annotations":["PostMapping"],"parameters":["String owner","String repo","String branch"],"body":"{\n    List<String> fileContents = GitHubRepoContents.listFileStructure(owner, repo, branch, \"\");\n    List<String> batchFiles = new ArrayList<>();\n    for (String str : fileContents) {\n        if (str.contains(\".java\") || str.contains(\".py\") || str.contains(\".js\")) {\n            String content = GitHubRepoContents.getFileContents(owner, repo, branch, str);\n            batchFiles.add(content);\n        }\n    }\n    List<String> documentList = new ArrayList<>();\n    GPTClient gpt = new GPTClient();\n    for (String x : batchFiles) {\n        String res = gpt.getDoc(x);\n        documentList.add(res);\n    }\n    // Generate PDF and return as response\n    try {\n        File pdfFile = generatePDF(documentList);\n        InputStreamResource resource = new InputStreamResource(new FileInputStream(pdfFile));\n        return ResponseEntity.ok().header(HttpHeaders.CONTENT_DISPOSITION, \"attachment; filename=documentation.pdf\").contentType(MediaType.APPLICATION_PDF).body(resource);\n    } catch (Exception e) {\n        return ResponseEntity.internalServerError().build();\n    }\n}"},{"name":"getdocs","returnType":"ResponseEntity<InputStreamResource>","annotations":["PostMapping"],"parameters":["String changedFiles"],"body":"{\n    JSONArray fileContents = new JSONArray(changedFiles);\n    List<String> batchFiles = new ArrayList<>();\n    for (int i = 0; i < fileContents.length(); i++) {\n        String str = fileContents.getString(i);\n        if (str.contains(\".java\") || str.contains(\".py\") || str.contains(\".js\")) {\n            String content = GitHubRepoContents.getFileContents(owner, repo, branch, str);\n            batchFiles.add(content);\n        }\n    }\n    List<String> documentList = new ArrayList<>();\n    GPTClient gpt = new GPTClient();\n    for (String x : batchFiles) {\n        String res = gpt.getDoc(x);\n        documentList.add(res);\n    }\n    // Generate PDF and return as response\n    try {\n        File pdfFile = generatePDF(documentList);\n        InputStreamResource resource = new InputStreamResource(new FileInputStream(pdfFile));\n        return ResponseEntity.ok().header(HttpHeaders.CONTENT_DISPOSITION, \"attachment; filename=documentation.pdf\").contentType(MediaType.APPLICATION_PDF).body(resource);\n    } catch (Exception e) {\n        return ResponseEntity.internalServerError().build();\n    }\n}"},{"name":"generatePDF","returnType":"File","annotations":[],"parameters":["List<String> documentList"],"body":"{\n    File pdfFile = File.createTempFile(\"documentation\", \".pdf\");\n    Document document = new Document();\n    PdfWriter.getInstance(document, new FileOutputStream(pdfFile));\n    document.open();\n    Font titleFont = new Font(Font.FontFamily.HELVETICA, 16, Font.BOLD);\n    Font contentFont = new Font(Font.FontFamily.HELVETICA, 12);\n    for (String doc : documentList) {\n        Paragraph title = new Paragraph(\"Documentation Section\", titleFont);\n        title.setSpacingBefore(10);\n        title.setSpacingAfter(5);\n        document.add(title);\n        Paragraph content = new Paragraph(doc, contentFont);\n        document.add(content);\n        document.add(new Paragraph(\"\\n----------------------\\n\"));\n    }\n    document.close();\n    return pdfFile;\n}"}],"nestedClasses":[]}]}  , "demo/src/main/java/com/devdocs/demo/controllers/JavaParserController.java ": 
{"imports":["com.devdocs.demo.utils.GitHubRepoContents","com.devdocs.demo.utils.SimpleJavaParser","com.devdocs.demo.utils.SimpleJavaParser.JavaFileStructure","org.springframework.web.bind.annotation.GetMapping","org.springframework.web.bind.annotation.RequestParam","org.springframework.web.bind.annotation.RestController"],"classes":[{"name":"JavaParserController","annotations":["RestController"],"extendedClass":"","implementedInterfaces":[],"fields":[],"methods":[{"name":"parseJavaCodeToJSON","returnType":"JavaFileStructure","annotations":["GetMapping"],"parameters":["String owner","String repo","String branch","String filePath"],"body":"{\n    //        int x = (int) filePath.charAt(filePath.length() - 1);\n    //        System.out.println(x);\n    //        System.out.println(filePath.length());\n    filePath = filePath.trim();\n    //        System.out.println(filePath.length());\n    String fileContent = GitHubRepoContents.getFileContents(owner, repo, branch, filePath);\n    return SimpleJavaParser.parseJavaCode(fileContent);\n    //        return null;\n}"}],"nestedClasses":[]}]}  , "demo/src/main/java/com/devdocs/demo/utils/GitHubRepoContents.java ": 
{"imports":["java.io.BufferedReader","java.io.InputStreamReader","java.net.HttpURLConnection","java.net.URL","java.util.Base64","java.util.HashMap","java.util.Map","org.json.JSONArray","org.json.JSONObject"],"classes":[{"name":"GitHubRepoContents","annotations":[],"extendedClass":"","implementedInterfaces":[],"fields":[{"name":"OWNER","type":"String","annotations":[]},{"name":"REPO","type":"String","annotations":[]},{"name":"BRANCH","type":"String","annotations":[]},{"name":"TOKEN","type":"String","annotations":[]},{"name":"RATE_LIMIT_DELAY","type":"int","annotations":[]},{"name":"rateLimitHeaders","type":"Map<String, Long>","annotations":[]}],"methods":[{"name":"main","returnType":"void","annotations":[],"parameters":["String[] args"],"body":"{\n    try {\n        // List the file structure\n        //            listFileStructure(OWNER, REPO, BRANCH, \"\");\n        // Retrieve and print the contents of a specific file\n        String filePath = \"demo/src/main/java/com/devdocs/demo/DemoApplication.java\";\n        String fileContents = getFileContents(OWNER, REPO, BRANCH, filePath);\n        //            System.out.println(fileContents);\n        //            System.out.println(\"Contents of \" + filePath + \":\");\n        //            System.out.println(fileContents);\n        System.out.println(SimpleJavaParser.parseJavaCode(fileContents));\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"},{"name":"listFileStructure","returnType":"void","annotations":[],"parameters":["String owner","String repo","String branch","String path"],"body":"{\n    String urlString = String.format(\"https://api.github.com/repos/%s/%s/contents/%s?ref=%s\", owner, repo, path, branch);\n    URL url = new URL(urlString);\n    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n    connection.setRequestMethod(\"GET\");\n    connection.setRequestProperty(\"Authorization\", \"token \" + TOKEN);\n    connection.setRequestProperty(\"Accept\", \"application/vnd.github.v3+json\");\n    checkRateLimit(connection);\n    int responseCode = connection.getResponseCode();\n    if (responseCode == 200) {\n        BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        String inputLine;\n        StringBuilder content = new StringBuilder();\n        while ((inputLine = in.readLine()) != null) {\n            content.append(inputLine);\n        }\n        in.close();\n        connection.disconnect();\n        JSONArray contents = new JSONArray(content.toString());\n        for (int i = 0; i < contents.length(); i++) {\n            JSONObject item = contents.getJSONObject(i);\n            if (item.getString(\"type\").equals(\"file\")) {\n                System.out.println(\"File: \" + item.getString(\"path\"));\n            } else if (item.getString(\"type\").equals(\"dir\")) {\n                System.out.println(\"Directory: \" + item.getString(\"path\"));\n                listFileStructure(owner, repo, branch, item.getString(\"path\"));\n            }\n        }\n    } else {\n        handleErrorResponse(connection);\n    }\n}"},{"name":"getFileContents","returnType":"String","annotations":[],"parameters":["String owner","String repo","String branch","String path"],"body":"{\n    String urlString = String.format(\"https://api.github.com/repos/%s/%s/contents/%s?ref=%s\", owner, repo, path, branch);\n    URL url = new URL(urlString);\n    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n    connection.setRequestMethod(\"GET\");\n    connection.setRequestProperty(\"Authorization\", \"token \" + TOKEN);\n    System.out.println(\"Env Variable for token : \" + TOKEN);\n    connection.setRequestProperty(\"Accept\", \"application/vnd.github.v3+json\");\n    checkRateLimit(connection);\n    int responseCode = connection.getResponseCode();\n    if (responseCode == 200) {\n        BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        String inputLine;\n        StringBuilder content = new StringBuilder();\n        while ((inputLine = in.readLine()) != null) {\n            content.append(inputLine);\n        }\n        in.close();\n        connection.disconnect();\n        JSONObject fileJson = new JSONObject(content.toString());\n        String encodedContent = fileJson.getString(\"content\").replaceAll(\"\\\\n\", \"\");\n        return new String(Base64.getDecoder().decode(encodedContent));\n    } else {\n        handleErrorResponse(connection);\n        return null;\n    }\n}"},{"name":"checkRateLimit","returnType":"void","annotations":[],"parameters":["HttpURLConnection connection"],"body":"{\n    if (rateLimitHeaders.containsKey(\"X-RateLimit-Remaining\") && rateLimitHeaders.get(\"X-RateLimit-Remaining\") == 0) {\n        try {\n            Thread.sleep(RATE_LIMIT_DELAY);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}"},{"name":"handleErrorResponse","returnType":"void","annotations":[],"parameters":["HttpURLConnection connection"],"body":"{\n    int responseCode = connection.getResponseCode();\n    System.out.println(\"Failed to retrieve contents: \" + responseCode);\n    BufferedReader in = new BufferedReader(new InputStreamReader(connection.getErrorStream()));\n    String inputLine;\n    StringBuilder content = new StringBuilder();\n    while ((inputLine = in.readLine()) != null) {\n        content.append(inputLine);\n    }\n    in.close();\n    connection.disconnect();\n    System.out.println(content.toString());\n}"}],"nestedClasses":[]}]}  , "demo/src/main/java/com/devdocs/demo/utils/GPTClient.java ": 
{"imports":["org.json.JSONArray","org.json.JSONObject","org.springframework.web.reactive.function.client.WebClient","org.springframework.web.reactive.function.client.WebClientResponseException","java.util.Map"],"classes":[{"name":"GPTClient","annotations":[],"extendedClass":"","implementedInterfaces":[],"fields":[{"name":"API_URL","type":"String","annotations":[]},{"name":"API_KEY","type":"String","annotations":[]},{"name":"webClient","type":"WebClient","annotations":[]}],"methods":[{"name":"getDoc","returnType":"String","annotations":[],"parameters":["String codeChunk"],"body":"{\n    String prompt = \"Create a developer-friendly documentation based on the given code:\\n\\n\" + codeChunk;\n    Map<String, Object> reqBody = Map.of(\"model\", \"gpt-4o-mini\", \"messages\", new Object[] { Map.of(\"role\", \"user\", \"content\", prompt) });\n    try {\n        String response = webClient.post().bodyValue(reqBody).retrieve().bodyToMono(String.class).block();\n        JSONObject jsonObject = new JSONObject(response);\n        JSONArray choices = jsonObject.getJSONArray(\"choices\");\n        if (choices.length() > 0) {\n            JSONObject message = choices.getJSONObject(0).getJSONObject(\"message\");\n            return message.getString(\"content\");\n        } else {\n            return \"Error: No response from API\";\n        }\n    } catch (WebClientResponseException e) {\n        return \"Error: \" + e.getMessage();\n    } catch (Exception e) {\n        return \"Unexpected Error: \" + e.getMessage();\n    }\n}"}],"nestedClasses":[]}]}  , "demo/src/main/java/com/devdocs/demo/utils/JavaFileStructure.java ": 
{"imports":["com.fasterxml.jackson.annotation.JsonAutoDetect","com.fasterxml.jackson.annotation.JsonInclude","java.util.ArrayList","java.util.List"],"classes":[{"name":"JavaFileStructure","annotations":["JsonAutoDetect","JsonInclude"],"extendedClass":"","implementedInterfaces":[],"fields":[{"name":"imports","type":"List<String>","annotations":[]},{"name":"classes","type":"List<JavaClassStructure>","annotations":[]}],"methods":[{"name":"toString","returnType":"String","annotations":["Override"],"parameters":[],"body":"{\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"Imports:\\n\");\n    imports.forEach(i -> sb.append(\"  \").append(i).append(\"\\n\"));\n    for (JavaClassStructure cls : classes) {\n        sb.append(\"\\nClass: \").append(cls.name).append(\"\\n\");\n        if (!cls.annotations.isEmpty()) {\n            sb.append(\"  Annotations: \").append(cls.annotations).append(\"\\n\");\n        }\n        if (!cls.extendedClass.isEmpty()) {\n            sb.append(\"  Extends: \").append(cls.extendedClass).append(\"\\n\");\n        }\n        if (!cls.implementedInterfaces.isEmpty()) {\n            sb.append(\"  Implements: \").append(cls.implementedInterfaces).append(\"\\n\");\n        }\n        sb.append(\"  Fields:\\n\");\n        for (JavaFieldStructure field : cls.fields) {\n            sb.append(\"    - \").append(field.type).append(\" \").append(field.name);\n            if (!field.annotations.isEmpty()) {\n                sb.append(\" (Annotations: \").append(field.annotations).append(\")\");\n            }\n            sb.append(\"\\n\");\n        }\n        sb.append(\"  Methods:\\n\");\n        for (JavaMethodStructure method : cls.methods) {\n            sb.append(\"    - \").append(method.returnType).append(\" \").append(method.name).append(\"(\").append(String.join(\", \", method.parameters)).append(\")\\n\");\n            if (!method.annotations.isEmpty()) {\n                sb.append(\"      Annotations: \").append(method.annotations).append(\"\\n\");\n            }\n            sb.append(\"      Body: \").append(method.body).append(\"\\n\");\n        }\n    }\n    return sb.toString();\n}"}],"nestedClasses":[{"name":"JavaClassStructure","annotations":["JsonAutoDetect","JsonInclude"],"extendedClass":"","implementedInterfaces":[],"fields":[{"name":"name","type":"String","annotations":[]},{"name":"extendedClass","type":"String","annotations":[]},{"name":"implementedInterfaces","type":"List<String>","annotations":[]},{"name":"annotations","type":"List<String>","annotations":[]},{"name":"fields","type":"List<JavaFieldStructure>","annotations":[]},{"name":"methods","type":"List<JavaMethodStructure>","annotations":[]}],"methods":[],"nestedClasses":[]},{"name":"JavaFieldStructure","annotations":["JsonAutoDetect","JsonInclude"],"extendedClass":"","implementedInterfaces":[],"fields":[{"name":"name","type":"String","annotations":[]},{"name":"type","type":"String","annotations":[]},{"name":"annotations","type":"List<String>","annotations":[]}],"methods":[],"nestedClasses":[]},{"name":"JavaMethodStructure","annotations":["JsonAutoDetect","JsonInclude"],"extendedClass":"","implementedInterfaces":[],"fields":[{"name":"name","type":"String","annotations":[]},{"name":"returnType","type":"String","annotations":[]},{"name":"parameters","type":"List<String>","annotations":[]},{"name":"annotations","type":"List<String>","annotations":[]},{"name":"body","type":"String","annotations":[]}],"methods":[],"nestedClasses":[]}]}]}  , "demo/src/main/java/com/devdocs/demo/utils/SimpleJavaParser.java ": 
{"imports":["com.fasterxml.jackson.databind.ObjectMapper","com.fasterxml.jackson.databind.SerializationFeature","com.github.javaparser.JavaParser","com.github.javaparser.ParseResult","com.github.javaparser.ast.CompilationUnit","com.github.javaparser.ast.ImportDeclaration","com.github.javaparser.ast.body","com.github.javaparser.ast.nodeTypes.NodeWithAnnotations","com.github.javaparser.ast.visitor.VoidVisitorAdapter","java.util"],"classes":[{"name":"SimpleJavaParser","annotations":[],"extendedClass":"","implementedInterfaces":[],"fields":[],"methods":[{"name":"main","returnType":"void","annotations":[],"parameters":["String[] args"],"body":"{\n    String javaCode = \"package com.cube.demo.rbxcb.rbxcb_3x3x3.Model;\\n\" + \"\\n\" + \"import java.util.*;\\n\" + \"import java.util.concurrent.*;\\n\" + \"import java.util.concurrent.atomic.AtomicReference;\\n\" + \"\\n\" + \"public class Cube implements Cloneable {\\n\" + \"\\n\" + \"    private static final Map<Character, EdgePos> nextEdgePos = Map.of(\\n\" + \"            'R', new EdgePos(new byte[]{0, 5, 2, 3, 4, 9, 1, 7, 8, 6, 10, 11}),\\n\" + \"            'U', new EdgePos(new byte[]{1, 2, 3, 0, 4, 5, 6, 7, 8, 9, 10, 11}),\\n\" + \"            'F', new EdgePos(new byte[]{0, 1, 6, 3, 4, 5, 10, 2, 8, 9, 7, 11}),\\n\" + \"            'B', new EdgePos(new byte[]{4, 1, 2, 3, 8, 0, 6, 7, 5, 9, 10, 11}),\\n\" + \"            'L', new EdgePos(new byte[]{0, 1, 2, 7, 3, 5, 6, 11, 8, 9, 10, 4}),\\n\" + \"            'D', new EdgePos(new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 11, 8, 9, 10})\\n\" + \"    );\\n\" + \"\\n\" + \"    private static final Map<Character, CornerPos> nextCornerPos = Map.of(\\n\" + \"            'R', new CornerPos(new byte[]{0, 5, 1, 3, 4, 6, 2, 7}),\\n\" + \"            'U', new CornerPos(new byte[]{1, 2, 3, 0, 4, 5, 6, 7}),\\n\" + \"            'F', new CornerPos(new byte[]{0, 1, 6, 2, 4, 5, 7, 3}),\\n\" + \"            'B', new CornerPos(new byte[]{4, 0, 2, 3, 5, 1, 6, 7}),\\n\" + \"            'L', new CornerPos(new byte[]{3, 1, 2, 7, 0, 5, 6, 4}),\\n\" + \"            'D', new CornerPos(new byte[]{0, 1, 2, 3, 7, 4, 5, 6})\\n\" + \"    );\\n\" + \"\\n\" + \"    private static final Map<Character, List<Map<Byte, Byte>>> nextEdgeOrientation = Map.of(\\n\" + \"            'R', List.of(\\n\" + \"                    Map.of((byte) 3, (byte) 3, (byte) 2, (byte) 2),\\n\" + \"                    Map.of((byte) 3, (byte) 2, (byte) 1, (byte) 1),\\n\" + \"                    Map.of((byte) 3, (byte) 3, (byte) -2, (byte) -2),\\n\" + \"                    Map.of((byte) 3, (byte) 3, (byte) -1, (byte) -1),\\n\" + \"                    Map.of((byte) 2, (byte) 2, (byte) -1, (byte) -1),\\n\" + \"                    Map.of((byte) 2, (byte) -3, (byte) 1, (byte) 1),\\n\" + \"                    Map.of((byte) -2, (byte) 3, (byte) 1, (byte) 1),\\n\" + \"                    Map.of((byte) -2, (byte) -2, (byte) -1, (byte) -1),\\n\" + \"                    Map.of((byte) 2, (byte) 2, (byte) -3, (byte) -3),\\n\" + \"                    Map.of((byte) 1, (byte) 1, (byte) -3, (byte) -2),\\n\" + \"                    Map.of((byte) -3, (byte) -3, (byte) -2, (byte) -2),\\n\" + \"                    Map.of((byte) -3, (byte) -3, (byte) -1, (byte) -1)\\n\" + \"            ),\\n\" + \"            'U', List.of(\\n\" + \"                    Map.of((byte) 3, (byte) 3, (byte) 2, (byte) 1),\\n\" + \"                    Map.of((byte) 3, (byte) 3, (byte) 1, (byte) -2),\\n\" + \"                    Map.of((byte) 3, (byte) 3, (byte) -2, (byte) -1),\\n\" + \"                    Map.of((byte) 3, (byte) 3, (byte) -1, (byte) 2),\\n\" + \"                    Map.of((byte) 2, (byte) 2, (byte) -1, (byte) -1),\\n\" + \"                    Map.of((byte) 2, (byte) 2, (byte) 1, (byte) 1),\\n\" + \"                    Map.of((byte) -2, (byte) -2, (byte) 1, (byte) 1),\\n\" + \"                    Map.of((byte) -2, (byte) -2, (byte) -1, (byte) -1),\\n\" + \"                    Map.of((byte) 2, (byte) 2, (byte) -3, (byte) -3),\\n\" + \"                    Map.of((byte) 1, (byte) 1, (byte) -3, (byte) -3),\\n\" + \"                    Map.of((byte) -3, (byte) -3, (byte) -2, (byte) -2),\\n\" + \"                    Map.of((byte) -3, (byte) -3, (byte) -1, (byte) -1)\\n\" + \"            ),\\n\" + \"            'F', List.of(\\n\" + \"                    Map.of((byte) 3, (byte) 3, (byte) 2, (byte) 2),\\n\" + \"                    Map.of((byte) 3, (byte) 3, (byte) 1, (byte) 1),\\n\" + \"                    Map.of((byte) 3, (byte) 1, (byte) -2, (byte) -2),\\n\" + \"                    Map.of((byte) 3, (byte) 3, (byte) -1, (byte) -1),\\n\" + \"                    Map.of((byte) 2, (byte) 2, (byte) -1, (byte) -1),\\n\" + \"                    Map.of((byte) 2, (byte) 2, (byte) 1, (byte) 1),\\n\" + \"                    Map.of((byte) -2, (byte) -2, (byte) 1, (byte) -3),\\n\" + \"                    Map.of((byte) -2, (byte) -2, (byte) -1, (byte) 3),\\n\" + \"                    Map.of((byte) 2, (byte) 2, (byte) -3, (byte) -3),\\n\" + \"                    Map.of((byte) 1, (byte) 1, (byte) -3, (byte) -3),\\n\" + \"                    Map.of((byte) -3, (byte) -1, (byte) -2, (byte) -2),\\n\" + \"                    Map.of((byte) -3, (byte) -3, (byte) -1, (byte) -1)\\n\" + \"            ),\\n\" + \"            'B', List.of(\\n\" + \"                    Map.of((byte) 3, (byte) -1, (byte) 2, (byte) 2),\\n\" + \"                    Map.of((byte) 3, (byte) 3, (byte) 1, (byte) 1),\\n\" + \"                    Map.of((byte) 3, (byte) 3, (byte) -2, (byte) -2),\\n\" + \"                    Map.of((byte) 3, (byte) 3, (byte) -1, (byte) -1),\\n\" + \"                    Map.of((byte) 2, (byte) 2, (byte) -1, (byte) -3),\\n\" + \"                    Map.of((byte) 2, (byte) 2, (byte) 1, (byte) 3),\\n\" + \"                    Map.of((byte) -2, (byte) -2, (byte) 1, (byte) 1),\\n\" + \"                    Map.of((byte) -2, (byte) -2, (byte) -1, (byte) -1),\\n\" + \"                    Map.of((byte) 2, (byte) 2, (byte) -3, (byte) 1),\\n\" + \"                    Map.of((byte) 1, (byte) 1, (byte) -3, (byte) -3),\\n\" + \"                    Map.of((byte) -3, (byte) -3, (byte) -2, (byte) -2),\\n\" + \"                    Map.of((byte) -3, (byte) -3, (byte) -1, (byte) -1)\\n\" + \"            ),\\n\" + \"            'L', List.of(\\n\" + \"                    Map.of((byte) 3, (byte) 3, (byte) 2, (byte) 2),\\n\" + \"                    Map.of((byte) 3, (byte) 3, (byte) 1, (byte) 1),\\n\" + \"                    Map.of((byte) 3, (byte) 3, (byte) -2, (byte) -2),\\n\" + \"                    Map.of((byte) 3, (byte) -2, (byte) -1, (byte) -1),\\n\" + \"                    Map.of((byte) 2, (byte) 3, (byte) -1, (byte) -1),\\n\" + \"                    Map.of((byte) 2, (byte) 2, (byte) 1, (byte) 1),\\n\" + \"                    Map.of((byte) -2, (byte) -2, (byte) 1, (byte) 1),\\n\" + \"                    Map.of((byte) -2, (byte) -3, (byte) -1, (byte) -1),\\n\" + \"                    Map.of((byte) 2, (byte) 2, (byte) -3, (byte) -3),\\n\" + \"                    Map.of((byte) 1, (byte) 1, (byte) -3, (byte) -3),\\n\" + \"                    Map.of((byte) -3, (byte) -3, (byte) -2, (byte) -2),\\n\" + \"                    Map.of((byte) -3, (byte) 2, (byte) -1, (byte) -1)\\n\" + \"            ),\\n\" + \"            'D', List.of(\\n\" + \"                    Map.of((byte) 3, (byte) 3, (byte) 2, (byte) 2),\\n\" + \"                    Map.of((byte) 3, (byte) 3, (byte) 1, (byte) 1),\\n\" + \"                    Map.of((byte) 3, (byte) 3, (byte) -2, (byte) -2),\\n\" + \"                    Map.of((byte) 3, (byte) 3, (byte) -1, (byte) -1),\\n\" + \"                    Map.of((byte) 2, (byte) 2, (byte) -1, (byte) -1),\\n\" + \"                    Map.of((byte) 2, (byte) 2, (byte) 1, (byte) 1),\\n\" + \"                    Map.of((byte) -2, (byte) -2, (byte) 1, (byte) 1),\\n\" + \"                    Map.of((byte) -2, (byte) -2, (byte) -1, (byte) -1),\\n\" + \"                    Map.of((byte) 2, (byte) -1, (byte) -3, (byte) -3),\\n\" + \"                    Map.of((byte) 1, (byte) 2, (byte) -3, (byte) -3),\\n\" + \"                    Map.of((byte) -3, (byte) -3, (byte) -2, (byte) 1),\\n\" + \"                    Map.of((byte) -3, (byte) -3, (byte) -1, (byte) -2)\\n\" + \"            )\\n\" + \"    );\\n\" + \"\\n\" + \"    private static final Map<Character, List<Map<Byte, Byte>>> nextCornerOrientation = Map.of(\\n\" + \"            'R', List.of(\\n\" + \"                    Map.of((byte) -1, (byte) -1, (byte) 2, (byte) 2, (byte) 3, (byte) 3),\\n\" + \"                    Map.of((byte) 1, (byte) 1, (byte) 2, (byte) -3, (byte) 3, (byte) 2),\\n\" + \"                    Map.of((byte) 1, (byte) 1, (byte) -2, (byte) 3, (byte) 3, (byte) 2),\\n\" + \"                    Map.of((byte) -1, (byte) -1, (byte) -2, (byte) -2, (byte) 3, (byte) 3),\\n\" + \"                    Map.of((byte) -1, (byte) -1, (byte) 2, (byte) 2, (byte) -3, (byte) -3),\\n\" + \"                    Map.of((byte) 1, (byte) 1, (byte) 2, (byte) -3, (byte) -3, (byte) -2),\\n\" + \"                    Map.of((byte) 1, (byte) 1, (byte) -2, (byte) 3, (byte) -3, (byte) -2),\\n\" + \"                    Map.of((byte) -1, (byte) -1, (byte) -2, (byte) -2, (byte) -3, (byte) -3)\\n\" + \"            ),\\n\" + \"            'U', List.of(\\n\" + \"                    Map.of((byte) -1, (byte) 2, (byte) 2, (byte) 1, (byte) 3, (byte) 3),\\n\" + \"                    Map.of((byte) 1, (byte) -2, (byte) 2, (byte) 1, (byte) 3, (byte) 3),\\n\" + \"                    Map.of((byte) 1, (byte) -2, (byte) -2, (byte) -1, (byte) 3, (byte) 3),\\n\" + \"                    Map.of((byte) -1, (byte) 2, (byte) -2, (byte) -1, (byte) 3, (byte) 3),\\n\" + \"                    Map.of((byte) -1, (byte) -1, (byte) 2, (byte) 2, (byte) -3, (byte) -3),\\n\" + \"                    Map.of((byte) 1, (byte) 1, (byte) 2, (byte) 2, (byte) -3, (byte) -3),\\n\" + \"                    Map.of((byte) 1, (byte) 1, (byte) -2, (byte) -2, (byte) -3, (byte) -3),\\n\" + \"                    Map.of((byte) -1, (byte) -1, (byte) -2, (byte) -2, (byte) -3, (byte) -3)\\n\" + \"            ),\\n\" + \"            'F', List.of(\\n\" + \"                    Map.of((byte) -1, (byte) -1, (byte) 2, (byte) 2, (byte) 3, (byte) 3),\\n\" + \"                    Map.of((byte) 1, (byte) 1, (byte) 2, (byte) 2, (byte) 3, (byte) 3),\\n\" + \"                    Map.of((byte) 1, (byte) -3, (byte) -2, (byte) -2, (byte) 3, (byte) 1),\\n\" + \"                    Map.of((byte) -1, (byte) 3, (byte) -2, (byte) -2, (byte) 3, (byte) 1),\\n\" + \"                    Map.of((byte) -1, (byte) -1, (byte) 2, (byte) 2, (byte) -3, (byte) -3),\\n\" + \"                    Map.of((byte) 1, (byte) 1, (byte) 2, (byte) 2, (byte) -3, (byte) -3),\\n\" + \"                    Map.of((byte) 1, (byte) -3, (byte) -2, (byte) -2, (byte) -3, (byte) -1),\\n\" + \"                    Map.of((byte) -1, (byte) 3, (byte) -2, (byte) -2, (byte) -3, (byte) -1)\\n\" + \"            ),\\n\" + \"            'B', List.of(\\n\" + \"                    Map.of((byte) -1, (byte) -3, (byte) 2, (byte) 2, (byte) 3, (byte) -1),\\n\" + \"                    Map.of((byte) 1, (byte) 3, (byte) 2, (byte) 2, (byte) 3, (byte) -1),\\n\" + \"                    Map.of((byte) 1, (byte) 1, (byte) -2, (byte) -2, (byte) 3, (byte) 3),\\n\" + \"                    Map.of((byte) -1, (byte) -1, (byte) -2, (byte) -2, (byte) 3, (byte) 3),\\n\" + \"                    Map.of((byte) -1, (byte) -3, (byte) 2, (byte) 2, (byte) -3, (byte) 1),\\n\" + \"                    Map.of((byte) 1, (byte) 3, (byte) 2, (byte) 2, (byte) -3, (byte) 1),\\n\" + \"                    Map.of((byte) 1, (byte) 1, (byte) -2, (byte) -2, (byte) -3, (byte) -3),\\n\" + \"                    Map.of((byte) -1, (byte) -1, (byte) -2, (byte) -2, (byte) -3, (byte) -3)\\n\" + \"            ),\\n\" + \"            'L', List.of(\\n\" + \"                    Map.of((byte) -1, (byte) -1, (byte) 2, (byte) 3, (byte) 3, (byte) -2),\\n\" + \"                    Map.of((byte) 1, (byte) 1, (byte) 2, (byte) 2, (byte) 3, (byte) 3),\\n\" + \"                    Map.of((byte) 1, (byte) 1, (byte) -2, (byte) -2, (byte) 3, (byte) 3),\\n\" + \"                    Map.of((byte) -1, (byte) -1, (byte) -2, (byte) -3, (byte) 3, (byte) -2),\\n\" + \"                    Map.of((byte) -1, (byte) -1, (byte) 2, (byte) 3, (byte) -3, (byte) 2),\\n\" + \"                    Map.of((byte) 1, (byte) 1, (byte) 2, (byte) 2, (byte) -3, (byte) -3),\\n\" + \"                    Map.of((byte) 1, (byte) 1, (byte) -2, (byte) -2, (byte) -3, (byte) -3),\\n\" + \"                    Map.of((byte) -1, (byte) -1, (byte) -2, (byte) -3, (byte) -3, (byte) 2)\\n\" + \"            ),\\n\" + \"            'D', List.of(\\n\" + \"                    Map.of((byte) -1, (byte) -1, (byte) 2, (byte) 2, (byte) 3, (byte) 3),\\n\" + \"                    Map.of((byte) 1, (byte) 1, (byte) 2, (byte) 2, (byte) 3, (byte) 3),\\n\" + \"                    Map.of((byte) 1, (byte) 1, (byte) -2, (byte) -2, (byte) 3, (byte) 3),\\n\" + \"                    Map.of((byte) -1, (byte) -1, (byte) -2, (byte) -2, (byte) 3, (byte) 3),\\n\" + \"                    Map.of((byte) -1, (byte) -2, (byte) 2, (byte) -1, (byte) -3, (byte) -3),\\n\" + \"                    Map.of((byte) 1, (byte) 2, (byte) 2, (byte) -1, (byte) -3, (byte) -3),\\n\" + \"                    Map.of((byte) 1, (byte) 2, (byte) -2, (byte) 1, (byte) -3, (byte) -3),\\n\" + \"                    Map.of((byte) -1, (byte) -2, (byte) -2, (byte) 1, (byte) -3, (byte) -3)\\n\" + \"            )\\n\" + \"    );\\n\" + \"\\n\" + \"    private static final byte[][] edgeList = {\\n\" + \"            {1, 37},\\n\" + \"            {5, 28},\\n\" + \"            {7, 19},\\n\" + \"            {3, 10},\\n\" + \"            {12, 41},\\n\" + \"            {32, 39},\\n\" + \"            {23, 30},\\n\" + \"            {14, 21},\\n\" + \"            {43, 52},\\n\" + \"            {34, 50},\\n\" + \"            {25, 46},\\n\" + \"            {16, 48}\\n\" + \"    };\\n\" + \"\\n\" + \"    private static final byte[][] cornerList = {\\n\" + \"            {0, 9, 38},\\n\" + \"            {2, 29, 36},\\n\" + \"            {8, 20, 27},\\n\" + \"            {6, 11, 18},\\n\" + \"            {15, 44, 51},\\n\" + \"            {35, 42, 53},\\n\" + \"            {26, 33, 47},\\n\" + \"            {17, 24, 45}\\n\" + \"    };\\n\" + \"\\n\" + \"    private static final Map<Character, Byte> binEncoding = Map.of(\\n\" + \"            'U', (byte) 0b100000,\\n\" + \"            'L', (byte) 0b010000,\\n\" + \"            'F', (byte) 0b001000,\\n\" + \"            'R', (byte) 0b000100,\\n\" + \"            'B', (byte) 0b000010,\\n\" + \"            'D', (byte) 0b000001\\n\" + \"    );\\n\" + \"\\n\" + \"    private static final Map<Character, Byte> priority = Map.of(\\n\" + \"            'U', (byte) 2,\\n\" + \"            'L', (byte) 0,\\n\" + \"            'F', (byte) 1,\\n\" + \"            'R', (byte) 0,\\n\" + \"            'B', (byte) 1,\\n\" + \"            'D', (byte) 2\\n\" + \"    );\\n\" + \"\\n\" + \"    private static final Map<Byte, Byte> edgeNumberForPos;\\n\" + \"    private static final Map<Byte, Byte> cornerNumberForPos;\\n\" + \"\\n\" + \"    static {\\n\" + \"        Map<Byte, Byte> edgeMap = new HashMap<>();\\n\" + \"        edgeMap.put((byte) 0b100010, (byte) 0);\\n\" + \"        edgeMap.put((byte) 0b100100, (byte) 1);\\n\" + \"        edgeMap.put((byte) 0b101000, (byte) 2);\\n\" + \"        edgeMap.put((byte) 0b110000, (byte) 3);\\n\" + \"        edgeMap.put((byte) 0b010010, (byte) 4);\\n\" + \"        edgeMap.put((byte) 0b000110, (byte) 5);\\n\" + \"        edgeMap.put((byte) 0b001100, (byte) 6);\\n\" + \"        edgeMap.put((byte) 0b011000, (byte) 7);\\n\" + \"        edgeMap.put((byte) 0b000011, (byte) 8);\\n\" + \"        edgeMap.put((byte) 0b000101, (byte) 9);\\n\" + \"        edgeMap.put((byte) 0b001001, (byte) 10);\\n\" + \"        edgeMap.put((byte) 0b010001, (byte) 11);\\n\" + \"\\n\" + \"        edgeNumberForPos = Collections.unmodifiableMap(edgeMap);\\n\" + \"\\n\" + \"        Map<Byte, Byte> cornerMap = new HashMap<>();\\n\" + \"        cornerMap.put((byte) 0b110010, (byte) 0);\\n\" + \"        cornerMap.put((byte) 0b100110, (byte) 1);\\n\" + \"        cornerMap.put((byte) 0b101100, (byte) 2);\\n\" + \"        cornerMap.put((byte) 0b111000, (byte) 3);\\n\" + \"        cornerMap.put((byte) 0b010011, (byte) 4);\\n\" + \"        cornerMap.put((byte) 0b000111, (byte) 5);\\n\" + \"        cornerMap.put((byte) 0b001101, (byte) 6);\\n\" + \"        cornerMap.put((byte) 0b011001, (byte) 7);\\n\" + \"\\n\" + \"        cornerNumberForPos = Collections.unmodifiableMap(cornerMap);\\n\" + \"    }\\n\" + \"\\n\" + \"    public static final int[][] edgePossiblePlacesStage3 = {\\n\" + \"            {1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0},\\n\" + \"            {0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1},\\n\" + \"            {1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0},\\n\" + \"            {0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1},\\n\" + \"            {0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0},\\n\" + \"            {0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0},\\n\" + \"            {0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0},\\n\" + \"            {0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0},\\n\" + \"            {1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0},\\n\" + \"            {0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1},\\n\" + \"            {1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0},\\n\" + \"            {0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1}};\\n\" + \"\\n\" + \"    public static final int[][] cornerPossiblePlacesStage3 = {\\n\" + \"            {1, 0, 1, 0, 0, 1, 0, 1},\\n\" + \"            {0, 1, 0, 1, 1, 0, 1, 0},\\n\" + \"            {1, 0, 1, 0, 0, 1, 0, 1},\\n\" + \"            {0, 1, 0, 1, 1, 0, 1, 0},\\n\" + \"            {0, 1, 0, 1, 1, 0, 1, 0},\\n\" + \"            {1, 0, 1, 0, 0, 1, 0, 1},\\n\" + \"            {0, 1, 0, 1, 1, 0, 1, 0},\\n\" + \"            {1, 0, 1, 0, 0, 1, 0, 1}};\\n\" + \"\\n\" + \"    private Edge edge;\\n\" + \"    private Corner corner;\\n\" + \"\\n\" + \"    public Cube() {\\n\" + \"        this.edge = new Edge();\\n\" + \"        this.corner = new Corner();\\n\" + \"    }\\n\" + \"\\n\" + \"    public Cube(Cube c) {\\n\" + \"        this.setEdge(new Edge(c.getEdge()));\\n\" + \"        this.setCorner(new Corner(c.getCorner()));\\n\" + \"    }\\n\" + \"\\n\" + \"    public Cube(Edge edge, Corner corner) {\\n\" + \"        this.edge = edge;\\n\" + \"        this.corner = corner;\\n\" + \"    }\\n\" + \"\\n\" + \"    public Cube(String colorInput) {\\n\" + \"        Cube c = new Cube();\\n\" + \"\\n\" + \"        EdgePos edgePos = c.getEdge().getEdgePos();\\n\" + \"        EdgeOrientation edgeOrientation = c.getEdge().getEdgeOrientation();\\n\" + \"\\n\" + \"        CornerPos cornerPos = c.getCorner().getCornerPos();\\n\" + \"        CornerOrientation cornerOrientation = c.getCorner().getCornerOrientation();\\n\" + \"\\n\" + \"        byte[] basicPositionsInfo = {4, 13, 22, 31, 40, 49}, basicOrientationInfo = {3, -1, -2, 1, 2, -3};\\n\" + \"        String basicPositions = \\\"ULFRBD\\\";\\n\" + \"\\n\" + \"        StringBuilder givenPositions = new StringBuilder();\\n\" + \"\\n\" + \"        HashMap<Character, Character> colorToSide = new HashMap<>();\\n\" + \"\\n\" + \"        for (int i = 0; i < basicOrientationInfo.length; i++)\\n\" + \"            givenPositions.append(colorInput.charAt(basicPositionsInfo[i]));\\n\" + \"\\n\" + \"        for (int i = 0; i < 6; i++)\\n\" + \"            colorToSide.put(givenPositions.charAt(i), basicPositions.charAt(i));\\n\" + \"\\n\" + \"        byte tempCounter = 0;\\n\" + \"\\n\" + \"        for (byte[] bytes : edgeList) {\\n\" + \"            char side1 = colorToSide.get(colorInput.charAt(bytes[0]));\\n\" + \"            char side2 = colorToSide.get(colorInput.charAt(bytes[1]));\\n\" + \"\\n\" + \"            byte binaryNum = (byte) (binEncoding.get(side1) ^ binEncoding.get(side2));\\n\" + \"\\n\" + \"            edgePos.setVal(edgeNumberForPos.get(binaryNum), tempCounter++);\\n\" + \"\\n\" + \"            byte priorityNumber = (byte) Math.max(priority.get(side1), priority.get(side2));\\n\" + \"            byte referenceNumber = priorityNumber == priority.get(side1) ? bytes[0] : bytes[1];\\n\" + \"\\n\" + \"            edgeOrientation.setVal(edgeNumberForPos.get(binaryNum), basicOrientationInfo[referenceNumber / 9]);\\n\" + \"        }\\n\" + \"\\n\" + \"        tempCounter = 0;\\n\" + \"\\n\" + \"        for (byte[] bytes : cornerList) {\\n\" + \"            char side1 = colorToSide.get(colorInput.charAt(bytes[0]));\\n\" + \"            char side2 = colorToSide.get(colorInput.charAt(bytes[1]));\\n\" + \"            char side3 = colorToSide.get(colorInput.charAt(bytes[2]));\\n\" + \"\\n\" + \"            byte binaryNum = (byte) (binEncoding.get(side1) ^ binEncoding.get(side2) ^ binEncoding.get(side3));\\n\" + \"\\n\" + \"            cornerPos.setVal(cornerNumberForPos.get(binaryNum), tempCounter++);\\n\" + \"\\n\" + \"            byte priorityNumber = (byte) Math.max(priority.get(side1), Math.max(priority.get(side2), priority.get(side3)));\\n\" + \"            byte referenceNumber = priorityNumber == priority.get(side1) ? bytes[0] : (priorityNumber == priority.get(side2) ? bytes[1] : bytes[2]);\\n\" + \"\\n\" + \"            cornerOrientation.setVal(cornerNumberForPos.get((binaryNum)), basicOrientationInfo[referenceNumber / 9]);\\n\" + \"        }\\n\" + \"\\n\" + \"        this.setEdge(new Edge(edgePos, edgeOrientation));\\n\" + \"        this.setCorner(new Corner(cornerPos, cornerOrientation));\\n\" + \"    }\\n\" + \"\\n\" + \"    @Override\\n\" + \"    public Cube clone() {\\n\" + \"        return new Cube(this.getEdge().clone(), this.getCorner().clone());\\n\" + \"    }\\n\" + \"\\n\" + \"    public static Cube execute(Cube c, String s) {\\n\" + \"        Cube temp = c.clone();\\n\" + \"\\n\" + \"        String[] moves = s.split(\\\" \\\");\\n\" + \"\\n\" + \"        if (moves.length > 1) {\\n\" + \"            StringBuilder sBuilder = new StringBuilder();\\n\" + \"\\n\" + \"            for (String string : moves) {\\n\" + \"                if (string.length() == 1)\\n\" + \"                    sBuilder.append(string.charAt(0));\\n\" + \"                else if (string.charAt(1) == '2')\\n\" + \"                    sBuilder.append(String.valueOf(string.charAt(0)).repeat(2));\\n\" + \"                else\\n\" + \"                    sBuilder.append(String.valueOf(string.charAt(0)).repeat(3));\\n\" + \"            }\\n\" + \"\\n\" + \"            s = sBuilder.toString();\\n\" + \"        }\\n\" + \"\\n\" + \"        for (int i = 0; i < s.length(); i++) {\\n\" + \"            char ch = s.charAt(i);\\n\" + \"\\n\" + \"            EdgePos edgePos = temp.getEdge().getEdgePos().clone();\\n\" + \"            EdgeOrientation edgeOrientation = temp.getEdge().getEdgeOrientation().clone();\\n\" + \"\\n\" + \"\\n\" + \"            for (int j = 0; j < 12; j++) {\\n\" + \"                edgeOrientation.setVal(j, nextEdgeOrientation.get(ch).get(edgePos.getVal()[j]).get(edgeOrientation.getVal()[j]));\\n\" + \"                edgePos.setVal(j, nextEdgePos.get(ch).getVal()[edgePos.getVal()[j]]);\\n\" + \"            }\\n\" + \"\\n\" + \"            temp.setEdge(new Edge(edgePos, edgeOrientation));\\n\" + \"\\n\" + \"            CornerPos cornerPos = temp.getCorner().getCornerPos().clone();\\n\" + \"            CornerOrientation cornerOrientation = temp.getCorner().getCornerOrientation().clone();\\n\" + \"\\n\" + \"            for (int j = 0; j < 8; j++) {\\n\" + \"                cornerOrientation.setVal(j, nextCornerOrientation.get(ch).get(cornerPos.getVal()[j]).get(cornerOrientation.getVal()[j]));\\n\" + \"                cornerPos.setVal(j, nextCornerPos.get(ch).getVal()[cornerPos.getVal()[j]]);\\n\" + \"            }\\n\" + \"\\n\" + \"            temp.setCorner(new Corner(cornerPos, cornerOrientation));\\n\" + \"        }\\n\" + \"        return temp;\\n\" + \"    }\\n\" + \"\\n\" + \"    public static String reverseAlgorithm(String s) {\\n\" + \"        StringBuilder result = new StringBuilder();\\n\" + \"\\n\" + \"        for (int i = 0; i < s.length(); i++)\\n\" + \"            result.append(String.valueOf(s.charAt(i)).repeat(3));\\n\" + \"\\n\" + \"        return new StringBuilder(result.toString()).reverse().toString();\\n\" + \"    }\\n\" + \"\\n\" + \"    public static ArrayList<String> getAlgorithm(String moves) {\\n\" + \"        class Temp {\\n\" + \"            final char ch;\\n\" + \"            final byte b;\\n\" + \"\\n\" + \"            public Temp(char ch, byte b) {\\n\" + \"                this.ch = ch;\\n\" + \"                this.b = b;\\n\" + \"            }\\n\" + \"        }\\n\" + \"\\n\" + \"        Stack<Temp> s = new Stack<>();\\n\" + \"\\n\" + \"        ArrayList<String> v = new ArrayList<>(Arrays.asList(\\\"\\\", \\\"\\\", \\\"2\\\", \\\"'\\\"));\\n\" + \"        ArrayList<String> result = new ArrayList<>();\\n\" + \"\\n\" + \"        for (int i = 0; i < moves.length(); i++) {\\n\" + \"            if (s.isEmpty() || s.peek().ch != moves.charAt(i))\\n\" + \"                s.push(new Temp(moves.charAt(i), (byte) 1));\\n\" + \"            else {\\n\" + \"                Temp x = s.pop();\\n\" + \"                if (x.b != (byte) 3)\\n\" + \"                    s.push(new Temp(x.ch, (byte) (x.b + 1)));\\n\" + \"            }\\n\" + \"        }\\n\" + \"\\n\" + \"        while (!s.isEmpty()) {\\n\" + \"            Temp x = s.pop();\\n\" + \"            if (x.b != 0)\\n\" + \"                result.add(0, x.ch + v.get(x.b));\\n\" + \"        }\\n\" + \"\\n\" + \"        return result;\\n\" + \"    }\\n\" + \"\\n\" + \"    @Override\\n\" + \"    public String toString() {\\n\" + \"        return \\\"Cube{\\\\n\\\" +\\n\" + \"                \\\"edge=\\\" + edge.toString() +\\n\" + \"                \\\",\\\\ncorner=\\\" + corner.toString() +\\n\" + \"                \\\"\\\\n}\\\";\\n\" + \"    }\\n\" + \"\\n\" + \"    public Edge getEdge() {\\n\" + \"        return edge;\\n\" + \"    }\\n\" + \"\\n\" + \"    public void setEdge(Edge edge) {\\n\" + \"        this.edge = edge;\\n\" + \"    }\\n\" + \"\\n\" + \"    public Corner getCorner() {\\n\" + \"        return corner;\\n\" + \"    }\\n\" + \"\\n\" + \"    public void setCorner(Corner corner) {\\n\" + \"        this.corner = corner;\\n\" + \"    }\\n\" + \"}\\n\" + \"\\n\" + \"// U2 L2 F R D R F R F' L' B U2 F R2 L2 F' U2 B L2 B\";\n    System.out.println(SimpleJavaParser.parseCodeToJSON(javaCode));\n}"},{"name":"parseJavaCode","returnType":"JavaFileStructure","annotations":[],"parameters":["String javaCode"],"body":"{\n    ParseResult<CompilationUnit> parseResult = new JavaParser().parse(javaCode);\n    if (parseResult.isSuccessful() && parseResult.getResult().isPresent()) {\n        CompilationUnit cu = parseResult.getResult().get();\n        JavaFileVisitor visitor = new JavaFileVisitor();\n        cu.accept(visitor, null);\n        return visitor.getJavaFileStructure();\n    } else {\n        System.err.println(\"Parsing failed: \" + parseResult.getProblems());\n        return null;\n    }\n}"},{"name":"parseCodeToJSON","returnType":"String","annotations":[],"parameters":["String fileContent"],"body":"{\n    ObjectMapper objectMapper = new ObjectMapper();\n    // Pretty print\n    objectMapper.enable(SerializationFeature.INDENT_OUTPUT);\n    try {\n        JavaFileStructure parsedStructure = SimpleJavaParser.parseJavaCode(fileContent);\n        if (parsedStructure == null) {\n            return objectMapper.writeValueAsString(Map.of(\"error\", \"Parsing failed\"));\n        }\n        return objectMapper.writeValueAsString(parsedStructure);\n    } catch (Exception e) {\n        e.printStackTrace();\n        try {\n            return objectMapper.writeValueAsString(Map.of(\"error\", \"Exception occurred: \" + e.getMessage()));\n        } catch (Exception ex) {\n            return \"{\\\"error\\\": \\\"Critical JSON serialization failure\\\"}\";\n        }\n    }\n}"}],"nestedClasses":[{"name":"JavaFileStructure","annotations":[],"extendedClass":"","implementedInterfaces":[],"fields":[{"name":"imports","type":"List<String>","annotations":[]},{"name":"classes","type":"List<JavaClassStructure>","annotations":[]}],"methods":[],"nestedClasses":[{"name":"JavaClassStructure","annotations":[],"extendedClass":"","implementedInterfaces":[],"fields":[{"name":"name","type":"String","annotations":[]},{"name":"annotations","type":"List<String>","annotations":[]},{"name":"extendedClass","type":"String","annotations":[]},{"name":"implementedInterfaces","type":"List<String>","annotations":[]},{"name":"fields","type":"List<JavaFieldStructure>","annotations":[]},{"name":"methods","type":"List<JavaMethodStructure>","annotations":[]},{"name":"nestedClasses","type":"List<JavaClassStructure>","annotations":[]}],"methods":[],"nestedClasses":[]},{"name":"JavaFieldStructure","annotations":[],"extendedClass":"","implementedInterfaces":[],"fields":[{"name":"name","type":"String","annotations":[]},{"name":"type","type":"String","annotations":[]},{"name":"annotations","type":"List<String>","annotations":[]}],"methods":[],"nestedClasses":[]},{"name":"JavaMethodStructure","annotations":[],"extendedClass":"","implementedInterfaces":[],"fields":[{"name":"name","type":"String","annotations":[]},{"name":"returnType","type":"String","annotations":[]},{"name":"annotations","type":"List<String>","annotations":[]},{"name":"parameters","type":"List<String>","annotations":[]},{"name":"body","type":"String","annotations":[]}],"methods":[],"nestedClasses":[]}]},{"name":"JavaFileVisitor","annotations":[],"extendedClass":"VoidVisitorAdapter","implementedInterfaces":[],"fields":[{"name":"javaFileStructure","type":"JavaFileStructure","annotations":[]},{"name":"classStack","type":"Stack<JavaFileStructure.JavaClassStructure>","annotations":[]},{"name":"methodStack","type":"Stack<JavaFileStructure.JavaMethodStructure>","annotations":[]}],"methods":[{"name":"visit","returnType":"void","annotations":["Override"],"parameters":["ImportDeclaration n","Void arg"],"body":"{\n    javaFileStructure.imports.add(n.getNameAsString());\n    super.visit(n, arg);\n}"},{"name":"visit","returnType":"void","annotations":["Override"],"parameters":["ClassOrInterfaceDeclaration n","Void arg"],"body":"{\n    JavaFileStructure.JavaClassStructure newClass = new JavaFileStructure.JavaClassStructure();\n    newClass.name = n.getNameAsString();\n    newClass.annotations = extractAnnotations(n);\n    newClass.extendedClass = n.getExtendedTypes().isNonEmpty() ? n.getExtendedTypes().get(0).getNameAsString() : \"\";\n    newClass.implementedInterfaces = n.getImplementedTypes().stream().map(t -> t.getNameAsString()).toList();\n    // Determine if this is a top-level, nested, or local class\n    if (classStack.isEmpty()) {\n        // Top-level class\n        javaFileStructure.classes.add(newClass);\n    } else if (!methodStack.isEmpty()) {\n        // Local class within a method\n        methodStack.peek().body += \"\\n[Local class: \" + newClass.name + \"]\";\n        // Still nest it for structure\n        classStack.peek().nestedClasses.add(newClass);\n    } else {\n        // Nested class within another class\n        classStack.peek().nestedClasses.add(newClass);\n    }\n    classStack.push(newClass);\n    super.visit(n, arg);\n    classStack.pop();\n}"},{"name":"visit","returnType":"void","annotations":["Override"],"parameters":["FieldDeclaration n","Void arg"],"body":"{\n    if (classStack.isEmpty()) {\n        System.err.println(\"Warning: FieldDeclaration found but no class exists in the structure.\");\n        return;\n    }\n    JavaFileStructure.JavaClassStructure currentClass = classStack.peek();\n    for (VariableDeclarator var : n.getVariables()) {\n        JavaFileStructure.JavaFieldStructure field = new JavaFileStructure.JavaFieldStructure();\n        field.name = var.getNameAsString();\n        field.type = var.getType().toString();\n        field.annotations = extractAnnotations(n);\n        currentClass.fields.add(field);\n    }\n    super.visit(n, arg);\n}"},{"name":"visit","returnType":"void","annotations":["Override"],"parameters":["MethodDeclaration n","Void arg"],"body":"{\n    if (classStack.isEmpty()) {\n        System.err.println(\"Warning: MethodDeclaration found but no class exists in the structure.\");\n        return;\n    }\n    JavaFileStructure.JavaClassStructure currentClass = classStack.peek();\n    JavaFileStructure.JavaMethodStructure method = new JavaFileStructure.JavaMethodStructure();\n    method.name = n.getNameAsString();\n    method.returnType = n.getType().toString();\n    method.annotations = extractAnnotations(n);\n    method.parameters = n.getParameters().stream().map(param -> param.getType() + \" \" + param.getNameAsString()).toList();\n    method.body = n.getBody().map(Object::toString).orElse(\"\");\n    currentClass.methods.add(method);\n    methodStack.push(method);\n    super.visit(n, arg);\n    methodStack.pop();\n}"},{"name":"extractAnnotations","returnType":"List<String>","annotations":[],"parameters":["NodeWithAnnotations<?> node"],"body":"{\n    return node.getAnnotations().stream().map(a -> a.getNameAsString()).toList();\n}"},{"name":"getJavaFileStructure","returnType":"JavaFileStructure","annotations":[],"parameters":[],"body":"{\n    return javaFileStructure;\n}"}],"nestedClasses":[]}]}]}  , "demo/src/test/java/com/devdocs/demo/DemoApplicationTests.java ": 
{"imports":["org.junit.jupiter.api.Test","org.springframework.boot.test.context.SpringBootTest"],"classes":[{"name":"DemoApplicationTests","annotations":["SpringBootTest"],"extendedClass":"","implementedInterfaces":[],"fields":[],"methods":[{"name":"contextLoads","returnType":"void","annotations":["Test"],"parameters":[],"body":"{\n}"}],"nestedClasses":[]}]}} 
